<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="../boilerplate/node_modules/three/build/three.min.js"></script>
    <script src="../boilerplate/node_modules/three/examples/js/controls/TransformControls.js"></script>
    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <!-- stats (fps, polygons, fps) -->
    <script src="../boilerplate/vrstats.js" type="module"></script>

    <script src="./node_modules/cannon/build/cannon.js"></script>

    <style type="text/css">
        html, body {
            margin:0;
            padding:0;
            overflow: hidden;
        }
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

    <!--
https://opengameart.org/content/cloudy-sky

https://freesound.org/people/JohanDeecke/sounds/368335/

https://freesound.org/people/Reitanna/sounds/323725/


    -->

</head>
<body>


<div id="overlay">
    <h1>Application Name</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    import {POINTER_CLICK, POINTER_PRESS,POINTER_RELEASE,Pointer} from '../boilerplate/pointer.js'
    import {t2 as T2} from "./t2.js"
    import VRStats from "../boilerplate/vrstats.js"
    import Button2D from "./button2d.js"
    import Label2D from "./label2d.js"
    import Panel2D from './panel2d.js'
    import Group2D from "./group2d.js"
    import {BlockService,BLOCK_TYPES} from "./BlockService.js"
    import GPUParticleSystem from "../particles/GPUParticleSystem.js"
    import BlockSelection from "./BlockSelection.js"
    import SimpleText from "./SimpleText.js"
    import FireBallAction from "./FireBallAction.js"
    import AudioService from "./AudioService.js"


    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)
    const toRad = (deg) => deg * Math.PI/180
    const rand = (min,max) => Math.random()*(max-min) + min

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;

    const game = {
        blockService:null,
        audioService:null,
        sound: {
            musicBuffer:null,
            clickSound:null,
            crashSound:null,
            thunkSound:null,
            bg_music:null,
        },
        physics: {
            floorBody: null,
        },
        click_sphere:null,
        ui: {
            play_game_button:null,
            crystalCountText:null,
        },
        actions: {
            fire_ball:null
        }
    }

    function parseOptions(opts) {
        let loc = document.location
        if (loc.search) {
            const parts = loc.search.substring(1).split('&')
            parts.forEach((part)=>{
                const keyval = part.split('=')
                opts[keyval[0]] = keyval[1]
            })
        }
        return opts;
    }

    const editor = {
        BASE_URL: "https://vr.josh.earth/360/doc/",
        docid: "tumble_level1",
        control:null
    }

    const opts = parseOptions({docid:'tumble_level1'})
    console.log(opts)
    editor.docid = opts.docid

    console.log("Loading the doc",editor.docid)


    const selection = new BlockSelection()
    function blockClicked(e) {
        selection.clear()
        selection.add(e.target.userData.block)
        editor.control.attach(e.target.userData.block.obj)
        game.ui.blockCount.set('text',`blocks: ${game.blockService.getAllBlocks().length}`)
    }


    let ignore_collisions = false
    let intervalId
    function togglePlayGame() {
        if(game.blockService.isPlaying()) {
            game.click_sphere.visible = false
            game.ui.play_game_button.set('text','play')
            game.blockService.stopPlaying()
            parts.forEach(part => scene.remove(part))
            parts = []
            clearInterval(intervalId)
            // if(game.sound.bg_music) game.sound.bg_music.stop()
            scene.remove(game.ui.crystalCountText)
            game.actions.fire_ball.setEnabled(false)
        } else {
            ignore_collisions = true
            setTimeout(()=>{
                ignore_collisions = false
            },500)
            game.actions.fire_ball.setEnabled(true)
            // game.sound.bg_music = game.audioService.play("bg")
            // game.sound.bg_music.loop = true
            game.click_sphere.visible = true
            game.ui.play_game_button.set('text','stop')
            game.blockService.startPlaying()
            intervalId = setInterval(()=>{
                const count = game.blockService.getAllBlocks()
                    .filter(b => b.physicsType === BLOCK_TYPES.CRYSTAL)
                    .filter(b => b.obj.visible)
                    .length
                game.ui.crystalCountText.setText(`crystals ${count}`)
            },1*1000)


            game.ui.crystalCountText = new SimpleText(2,1);
            game.ui.crystalCountText.setText("playing")
            game.ui.crystalCountText.position.set(0,3,-2)
            scene.add(game.ui.crystalCountText)
        }
    }

    function addBlock() {
        const block = game.blockService.makeBlock()
        block.positionSet(0,1.0,0)
        on(block.getObject3D(), 'click', blockClicked)
        selection.clear()
        selection.add(block)
        editor.control.attach(block.getObject3D())
    }

    function deleteBlock() {
        selection.getBlocks().forEach((b)=> game.blockService.remove(b))
        editor.control.detach()
        selection.clear()
    }

    function cloneBlock() {
        const newBlocks = selection.getBlocks().map(b => {
            const bb = game.blockService.cloneBlock(b)
            const v3 = b.getObject3D().position.clone().add(new THREE.Vector3(1.5,0,0))
            bb.setPosition(v3)
            on(bb.getObject3D(), 'click', blockClicked)
            return bb
        })
        selection.clear()
        newBlocks.forEach(b => selection.add(b))
        if(newBlocks.length > 0) editor.control.attach(newBlocks[0].getObject3D())

    }

    function initAudio() {
        game.audioService = new AudioService()
        game.audioService.load("click","./sounds/plink.wav")
        game.audioService.load("crash","./sounds/crash1.wav")
        game.audioService.load("thunk","./sounds/thunk.wav")
        game.audioService.load("bg","./music/Visager_-_09_-_Bug_Band_Loop.mp3")
    }


    const texture_loader = new THREE.TextureLoader()
    const spark_texture = texture_loader.load('../particles/spark.png')
    let parts = []

    function playParticles(pos) {
        const options = {
            position: new THREE.Vector3(0,0,0),
            positionRandomness: 0.0,
            velocity: new THREE.Vector3(0.0, 0, 0.0),
            velocityRandomness: 1.0,
            acceleration: new THREE.Vector3(0.0,0.0,0.0),

            color: new THREE.Color(1.0,1.0,1.0),
            endColor: new THREE.Color(1.0,1.0,1.0),

            lifetime: 1.0,
            fadeIn:0.001,
            fadeOut:0.001,
            size: 30,
            sizeRandomness: 0.0,
        }
        const time = new THREE.Clock()
        time.start()
        const part = new GPUParticleSystem({
            maxParticles: 10000,
            particleSpriteTex: spark_texture,
            blending: THREE.AdditiveBlending,
            onTick: (system, t) => {
                if (time.getElapsedTime() > 1.0) return
                const s = 1.0
                for(let i=0; i<10; i++) {
                    options.velocity.set(rand(-s, s), rand(-s, s), rand(-s, s))
                    options.position.copy( options.velocity)
                    system.spawnParticle(options)
                }
            }
        })
        part.position.copy(pos)
        scene.add(part)
        parts.push(part)
    }

    function destroyCrystal(target) {
        //play glass break sound
        game.audioService.play('crash')
        //remove the block from the scene and simulation
        //must do in a timeout because we are currently in a collide callback
        setTimeout(()=>game.blockService.removeFromSimulation(target),0)
        //add explosion effects
        const v = new THREE.Vector3()
        target.userData.block.obj.localToWorld(v)
        playParticles(v)
    }

    function handleCollision(e) {
        if(ignore_collisions) return
        //ignore tiny collisions
        if(Math.abs(e.contact.getImpactVelocityAlongNormal() < 1.0)) return

        //ignore the ball hitting the floor
        //this is never called. why?
        // if(e.body.jtype === BLOCK_TYPES.BALL && e.target.jtype === BLOCK_TYPES.FLOOR) {
        //     console.log("floor")
        //     return
        // }

        // console.log(e.body.jtype, 'hit', e.target.jtype, e.target.type)

        //ignore the ball hitting a static body
        // if(e.body.jtype === BLOCK_TYPES.BALL && e.target.type === CANNON.Body.KINEMATIC) return

        //when ball hits moving block,
        if(e.body.jtype === BLOCK_TYPES.BALL) {
            if (e.target.jtype === BLOCK_TYPES.CRYSTAL) return destroyCrystal(e.target)
            if (e.target.jtype === BLOCK_TYPES.BLOCK) {
                //hit a block, just make the thunk sound
                game.audioService.play('click')
            }
        }
        //when crystal hits a block
        // if(e.body.jtype === BLOCK_TYPES.CRYSTAL) {
        //     if(e.target.jtype === BLOCK_TYPES.BLOCK) {
        //         console.log("crystal hit a block")
        //     }
        //     if(e.target.jtype === BLOCK_TYPES.FLOOR) {
        //         console.log("crystal hit the floor")
        //     }
        // }

        //if floor hits a crystal
        if(e.body.jtype === BLOCK_TYPES.FLOOR) {
            if(e.target.jtype === BLOCK_TYPES.CRYSTAL) return destroyCrystal(e.target)
        }

        //if the floor hit a block, ignore
        // if(e.body.jtype === BLOCK_TYPES.FLOOR && e.target.jtype === BLOCK_TYPES.BLOCK) return

        // console.log("contact",e)
        /*
        if(e.body.id === game.physics.floorBody.id) return
        if(!e.contact.userData) e.contact.userData = {}
        if(e.contact.userData.soundPlayed === true) return
        e.contact.userData.soundPlayed = true
        */
    }

    function initBlocks(scene) {
        const block2 = game.blockService.makeBlock()
        block2.positionSet(-2,1,0)
        on(block2.getObject3D(),'click',blockClicked)
        const block1 = game.blockService.makeBlock()
        block1.positionSet(0,1,0)
        on(block1.getObject3D(),'click',blockClicked)
        const block3 = game.blockService.makeBlock()
        block3.positionSet(2,1,0)
        on(block3.getObject3D(),'click',blockClicked)
        selection.add(block1)
    }

    function saveStructure() {
        const blockData = game.blockService.generateJSON()
        const doc = {
            id:editor.docid,
            type:'tumble-v1',
            data:{
                blocks:blockData,
                ballMass:game.blockService.ballMass,
                ballRadius:game.blockService.ballRadius,
                wallFriction:game.blockService.wallFriction,
                wallRestitution:game.blockService.wallRestitution,
                gravity: {x:0,y:-9.8,z:0},
            },
        }
        console.log('saving document', JSON.stringify(doc,null,'  '))
        fetch(`${editor.BASE_URL}${editor.docid}`,{
            method:'POST',
            mode:'cors',
            headers: {
                'Content-Type':'application/json'
            },
            body:JSON.stringify(doc)
        })
            .then(resp => resp.json())
            .then(resp => {
                console.log("real response is",resp)
            })
            .catch(e => {
                console.log(e)
            })

    }

    class EventMaker {
        constructor() {
            this.listeners = {}
        }
        addEventListener(type,cb) {
            if(!this.listeners[type]) this.listeners[type] = []
            this.listeners[type].push(cb)
        }
        fire(type,evt) {
            if(!this.listeners[type]) this.listeners[type] = []
            this.listeners[type].forEach(cb => cb(evt))
        }

    }
    const dataChanger = new EventMaker()

    function loadStructure() {
        fetch(`${editor.BASE_URL}${editor.docid}?cachebust=${Math.random()}`)
            .then(res => res.json())
            .then(res => {
                const blocks = game.blockService.loadFromJSON(res)
                blocks.forEach(b => {
                    on(b.getObject3D(), 'click', blockClicked)
                })
                dataChanger.fire('changed',{})
            })
    }

    function initPanel(scene) {

        const panel = new Panel2D(scene,camera)
        scene.add(panel)

        const subPanels = []
        function switchTo(panel) {
            subPanels.forEach(p =>  p.set('visible',(p===panel)))
        }

        const posPanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',true)
        subPanels.push(posPanel)
        panel.add(posPanel)

        const sizPanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',false)
        subPanels.push(sizPanel)
        panel.add(sizPanel)

        const rotPanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',false)
        panel.add(rotPanel)
        subPanels.push(rotPanel)

        panel.add(new Button2D()
            .set('text','pos')
            .set('x',5).set('y',5)
            .on('click',()=> switchTo(posPanel))
        )
        panel.add(new Button2D()
            .set('text','siz')
            .set('x',50).set('y',5)
            .on('click',()=> switchTo(sizPanel))
        )
        panel.add(new Button2D()
            .set('text','rot')
            .set('x',87).set('y',5)
            .on('click',()=>switchTo(rotPanel))
        )

        const rowLayout = (panel)=>{
            let x = 0
            panel.comps.forEach((c)=>{
                c.x=x
                c.y=0
                x += c.w+5
            })
        }
        const colLayout = (panel) => {
            let y = 0
            panel.comps.forEach((c)=>{
                c.x=0
                c.y=y
                y += c.h+5
            })
        }

        const typePanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',false)
            .set('layout',rowLayout)
        subPanels.push(typePanel)
        panel.add(typePanel)

        panel.add(new Button2D()
            .set('text','type')
            .set('x',125).set('y',5)
            .on('click',()=> switchTo(typePanel))
        )

        typePanel.addAll([
            new Button2D().set('text','block')
                .on('click',()=> selection.setPropertyValue('physicstype',BLOCK_TYPES.BLOCK)),
            new Button2D().set('text','wall')
                .on('click',()=> selection.setPropertyValue('physicstype',BLOCK_TYPES.WALL)),
            new Button2D().set('text','crystal')
                .on('click',()=> selection.setPropertyValue('physicstype',BLOCK_TYPES.CRYSTAL))
        ])






        const settingsPanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',false)
        subPanels.push(settingsPanel)
        panel.add(settingsPanel)

        panel.add(new Button2D()
            .set('text','settings')
            .set('x',175).set('y',5)
            .on('click',()=>{ switchTo(settingsPanel) })
        )

        function makeValueSetter(name,y, getter, setter, step) {
            const value = new Label2D()
                .set('text',getter().toFixed(2))
                .set('x',150).set('y',y).set('fsize',20)
            const dec = () => setter(getter()-step)
            const inc = () => setter(getter()+step)
            on(dataChanger,'changed',()=>{
                value.set('text',getter().toFixed(2))
                panel.redraw()
            })
            return [
                new Label2D().set('text',name).set('x',0).set('y',y).set('fsize',20),
                new Button2D().set('x',100).set('y',y).set('text','-').on('click',dec),
                new Button2D().set('x',120).set('y',y).set('text','+').on('click',inc),
                value,
            ]
        }
        settingsPanel.addAll(makeValueSetter('ball radius', 0,
            ()=> game.blockService.ballRadius,
            (v)=> {
                game.blockService.ballRadius = v
                dataChanger.fire('changed')
            },
            0.1 ))
        settingsPanel.addAll(makeValueSetter('ball mass',   35,
            ()=> game.blockService.ballMass,
            (v)=> {
                game.blockService.ballMass = v
                dataChanger.fire('changed')
            },
            2.0))
        settingsPanel.addAll(makeValueSetter('friction',    70,
            ()=> game.blockService.wallFriction,
            (v)=> {
                game.blockService.wallFriction = v
                game.blockService.rebuildWallMaterial()
                dataChanger.fire('changed')
            },
            0.1
            ))
        settingsPanel.addAll(makeValueSetter('restitution', 105,
            ()=> game.blockService.wallRestitution,
            (v)=> {
                game.blockService.wallRestitution = v
                game.blockService.rebuildWallMaterial()
                dataChanger.fire('changed')
            },
            0.1
            ))



        function makePropControls(name,y) {
            const label = new Label2D().set('x',0).set('y',y).set('text',name.toUpperCase())
            const value = new Label2D().set('x',150).set('y',y).set('text','0')
            const inc   = new Button2D().set('x',90).set('y',y).set('text','-').on('click',()=> selection.decrementProperty(name))
            const dec   = new Button2D().set('x',120).set('y',y).set('text','+').on('click',()=> selection.incrementProperty(name))
            on(selection,'changed',()=>{
                value.set('text',''+selection.getProperty(name).toFixed(2))
                panel.redraw()
            })
            return [label,inc,dec,value]
        }

        ['x','y','z'].forEach((name,i) => posPanel.addAll(makePropControls(name,40*i)));
        ["w","h","d"].forEach((name, i)=> sizPanel.addAll(makePropControls(name,40*i)));
        ["rotx","roty","rotz"].forEach((name, i)=> rotPanel.addAll(makePropControls(name,40*i)));

        const actionGroup = new Group2D()
            .set('x',5)
            .set('y',250)
            .set('w',100)
            .set('h',250)
            .set('layout',colLayout)
        panel.add(actionGroup)

        actionGroup.add(new Button2D().set('text','select all')
            .on('click',()=>{
                selection.clear()
                selection.addAll(game.blockService.getAllBlocks())
            })
        )
        actionGroup.add(new Button2D().set('text','add').on('click',addBlock))
        actionGroup.add(new Button2D().set('text','delete').on('click',deleteBlock))
        actionGroup.add(new Button2D().set('text','clone').on('click',cloneBlock))
        actionGroup.add(new Button2D().set('text','save').on('click',saveStructure))
        game.ui.play_game_button = new Button2D().set('text','play').on('click',togglePlayGame)
        actionGroup.add(game.ui.play_game_button)

        const viewGroup = new Group2D().set('x',110).set('y',250).set('w',100).set('h',130).set('layout',colLayout)
        panel.add(viewGroup)
        viewGroup.add(new Button2D().set('text','CCW').on('click',()=>game.blockService.rotateCCW()))
        viewGroup.add(new Button2D().set('text','CW').on('click',()=>game.blockService.rotateCW()))
        viewGroup.add(new Button2D().set('text','RST').on('click',()=>game.blockService.rotateReset()))

        panel.add(new Label2D()
            .set('text',`editing ${editor.docid}`)
            .set('fsize',15)
            .set('x',100).set('y',480)
        )

        game.ui.blockCount = new Label2D()
            .set('text',`blocks:`)
            .set('fsize',15)
            .set('x',100).set('y',460);
        panel.add(game.ui.blockCount)

        panel.redraw()
        panel.position.set(-1.5,1.5,-2)
        panel.lookAt(camera.position)
    }

    function initTransformControls(scene) {
        editor.control = new THREE.TransformControls(camera,renderer.domElement)
        editor.control.setTranslationSnap(0.1)
        editor.control.setSpace('local')
        editor.control.setSize(3)
        // on(editor.control,'change',(e)=>{
        //     console.log("trnasform control chnaged",e.target)
        // })
        on(editor.control,'dragging-changed',(e)=>{
            const blk = selection.getBlocks()[0]
            blk.setPosition(blk.obj.position.clone())
        })
        scene.add(editor.control)
    }

    function initContent(scene,camera,renderer) {
        game.blockService = new BlockService(scene,handleCollision)
        initAudio()
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap

        //set the background color of the scene
        scene.background = new THREE.Color( 0xcccccc );

        //a standard light
        const light = new THREE.DirectionalLight( 0xffffff, 0.5 );
        light.castShadow = true
        light.shadow.mapSize.width = 512
        light.shadow.mapSize.height = 512
        light.shadow.camera.right = 10
        light.shadow.camera.top = 10
        light.position.set( 0, 1, 1 ).normalize();
        scene.add( light );

        scene.add(new THREE.AmbientLight(0xffffff,0.5))





        // enable stats visible inside VR
        stats = new VRStats(renderer)
        camera.add(stats)
        scene.add(camera)

        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {

            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),

            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:true,

            // set to true to move the controller node forward and tilt with the mouse.
            // good for testing VR controls on desktop
            mouseSimulatesController:false,
            enableLaser: true,
            laserLength:8,
        })



        initBlocks(scene)

        initPanel(scene)

        initFloor(scene)

        initBall(scene)

        initTransformControls(scene)

        $("#overlay").style.visibility = 'hidden'
        if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')

        loadStructure()
    }

    function initFloor(scene) {
        //mesh for the floor
        const floor =new THREE.Mesh(
            new THREE.PlaneGeometry(30,30,32,32),
            new THREE.MeshLambertMaterial({color:'brown'})
        )
        floor.rotation.x = toRad(-90)
        scene.add(floor)

        //physics for the floor
        game.physics.floorBody = new CANNON.Body({
            mass: 0 // mass == 0 makes the body static
        });
        var groundShape = new CANNON.Plane();
        game.physics.floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
        game.physics.floorBody.addShape(groundShape);
        game.blockService.getWorld().addBody(game.physics.floorBody);
        game.physics.floorBody.jtype = BLOCK_TYPES.FLOOR

        //background image
        scene.add(new THREE.Mesh(
            new THREE.SphereGeometry(20),
            new THREE.MeshBasicMaterial({
                color:'white',
                map:texture_loader.load('./textures/sky2.jpg'),
                side: THREE.BackSide
            })
        ))

        //floor of the game area
        const gameFloor = new THREE.Mesh(
            new THREE.CircleGeometry(3),
            new THREE.MeshLambertMaterial({color:'magenta'})
        )
        gameFloor.rotation.x = toRad(-90)
        gameFloor.position.y = 0.01
        gameFloor.receiveShadow = true
        game.blockService.group.add(gameFloor)
    }



    function initBall(scene) {
        game.click_sphere = new THREE.Mesh(
            new THREE.SphereGeometry(4),
            new THREE.MeshLambertMaterial({color:'green', side:THREE.BackSide, transparent:true, opacity:0.3})
        )
        game.click_sphere.visible = false
        game.click_sphere.material.visible = false
        game.click_sphere.userData.clickable = true
        game.click_sphere.position.set(0,0,0)
        scene.add(game.click_sphere)

        game.actions.fire_ball = new FireBallAction(scene, pointer.controller1, game)
        on(game.click_sphere,POINTER_PRESS,game.actions.fire_ball.startPressSphere)
        on(game.click_sphere,POINTER_RELEASE,game.actions.fire_ball.endPressSphere)
    }

    //called on every frame. customize this
    function render(time) {
        T2.update(time)
        //update the pointer and stats, if configured
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        parts.forEach(part =>  part.update(time))
        game.blockService.update(time)
        if(game.actions.fire_ball) game.actions.fire_ball.updatePressSphere(time)
        renderer.render( scene, camera );
    }


    // you shouldn't need to modify much below here

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }



    // initPage()
    initScene()
    renderer.setAnimationLoop(render)

</script>
</body>
</html>
