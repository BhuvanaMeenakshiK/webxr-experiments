<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="../boilerplate/node_modules/three/build/three.min.js"></script>
    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <!-- stats (fps, polygons, fps) -->
    <script src="../boilerplate/vrstats.js" type="module"></script>

    <script src="./node_modules/cannon/build/cannon.js"></script>

    <style type="text/css">
        html, body {
            margin:0;
            padding:0;
            overflow: hidden;
        }
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

    <!--
https://opengameart.org/content/cloudy-sky

    -->

</head>
<body>


<div id="overlay">
    <h1>Application Name</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    import {POINTER_CLICK, POINTER_PRESS,POINTER_RELEASE,Pointer} from '../boilerplate/pointer.js'
    import {t2 as T2} from "./t2.js"
    import VRStats from "../boilerplate/vrstats.js"
    import Button2D from "./button2d.js"
    import Label2D from "./label2d.js"
    import Panel2D from './panel2d.js'
    import Group2D from "./group2d.js"
    import {BlockService} from "./BlockService.js"
    import GPUParticleSystem from "../particles/GPUParticleSystem.js"

    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)
    const toRad = (deg) => deg * Math.PI/180
    const rand = (min,max) => Math.random()*(max-min) + min

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;

    let blockService
    let click_sphere
    let floorBody

    const PROP_NAMES = ['x','y','z','rotx','roty','rotz','w','h','d']

    class BlockSelection {
        constructor() {
            this.blocks = []
            this.listeners = {}
        }
        on(type,cb) {
            this.addEventListener(type,cb)
        }
        addEventListener(type,cb) {
            if(!this.listeners[type]) this.listeners[type] = []
            this.listeners[type].push(cb)
        }
        fire(type) {
            if(!this.listeners[type]) this.listeners[type] = []
            this.listeners[type].forEach(cb => cb())
        }
        clear() {
            this.blocks.forEach(obj=>obj.unselectSelf())
            this.blocks = []
            this.fire('changed')
        }
        add(obj) {
            this.blocks.push(obj)
            obj.selectSelf()
            this.fire('changed')
        }
        addAll(arr) {
            arr.forEach(b => this.add(b))
        }
        getBlocks() {
            return this.blocks
        }
        decrementProperty(name) {
            this.blocks.forEach(b => {
                if(PROP_NAMES.indexOf(name) >= 0) {
                    b.set(name, b.get(name)-0.1)
                    return
                }
            })
            this.fire('changed')
        }
        incrementProperty(name) {
            this.blocks.forEach(b => {
                if(PROP_NAMES.indexOf(name) >= 0) {
                    b.set(name, b.get(name)+0.1)
                    return
                }
            })
            this.fire('changed')
        }
        getProperty(name) {
            if(this.blocks.length <= 0) return -1
            const block = this.blocks[0]
            if(PROP_NAMES.indexOf(name) >= 0) {
                return block.get(name)
            }
            return -1
        }
        setPropertyValue(name,value) {
            this.blocks.forEach(b => {
                b.set(name,value)
            })
        }
    }

    const selection = new BlockSelection()
    function blockClicked(e) {
        selection.clear()
        selection.add(e.target.userData.block)
    }


    let play_game_button = null
    let bg_music
    let ignore_collisions = false
    function togglePlayGame() {
        if(blockService.isPlaying()) {
            click_sphere.visible = false
            play_game_button.set('text','play')
            blockService.stopPlaying()
            parts.forEach(part => scene.remove(part))
            parts = []
            if(bg_music) bg_music.stop()
        } else {
            ignore_collisions = true
            setTimeout(()=>{
                ignore_collisions = false
            },500)
            bg_music = playSource(musicBuffer)
            bg_music.loop = true
            click_sphere.visible = true
            play_game_button.set('text','stop')
            blockService.startPlaying()
        }
    }

    function addBlock() {
        const block = blockService.makeBlock()
        block.positionSet(0,1.0,0)
        on(block.getObject3D(), 'click', blockClicked)
        selection.clear()
        selection.add(block)
    }

    function deleteBlock() {
        selection.getBlocks().forEach((b)=> blockService.remove(b))
        selection.clear()
    }

    function cloneBlock() {
        const newBlocks = selection.getBlocks().map(b => {
            const bb = blockService.cloneBlock(b)
            const v3 = b.getObject3D().position.clone().add(new THREE.Vector3(1.5,0,0))
            bb.setPosition(v3)
            on(bb.getObject3D(), 'click', blockClicked)
            return bb
        })
        selection.clear()
        newBlocks.forEach(b => selection.add(b))
    }

    window.AudioContext = window.AudioContext || window.webkitAudioContext
    let context = new window.AudioContext()
    let audioBuffer, musicBuffer
    function getAudioFile(url) {
        return fetch(url,{responseType:'arraybuffer'})
            .then(resp => resp.arrayBuffer())
            .then(arr => context.decodeAudioData(arr))
    }
    function playSource(buffer) {
        const source = context.createBufferSource();
        source.buffer = buffer;
        source.connect(context.destination);
        source.start(0)
        return source
    }
    //get the audio file and save the buffer as 'audioBuffer'
    getAudioFile('./sounds/plink.wav').then(buffer=> audioBuffer = buffer)
    getAudioFile("./music/Visager_-_09_-_Bug_Band_Loop.mp3").then(b => musicBuffer = b)


    const texture_loader = new THREE.TextureLoader()
    const spark_texture = texture_loader.load('../particles/spark.png')
    let parts = []

    function playParticles(pos) {
        const options = {
            position: new THREE.Vector3(0,0,0),
            positionRandomness: 0.0,
            velocity: new THREE.Vector3(0.0, 0, 0.0),
            velocityRandomness: 1.0,
            acceleration: new THREE.Vector3(0.0,0.0,0.0),

            color: new THREE.Color(1.0,1.0,1.0),
            endColor: new THREE.Color(1.0,1.0,1.0),

            lifetime: 1.0,
            fadeIn:0.001,
            fadeOut:0.001,
            size: 30,
            sizeRandomness: 0.0,
        }
        const time = new THREE.Clock()
        time.start()
        const part = new GPUParticleSystem({
            maxParticles: 10000,
            particleSpriteTex: spark_texture,
            blending: THREE.NormalBlending,
            onTick: (system, t) => {
                if (time.getElapsedTime() > 1.0) return
                const s = 1.0
                for(let i=0; i<10; i++) {
                    options.velocity.set(rand(-s, s), rand(-s, s), rand(-s, s))
                    options.position.copy( options.velocity)
                    system.spawnParticle(options)
                }
            }
        })
        part.position.copy(pos)
        scene.add(part)
        parts.push(part)
    }
    function ballHitMovableBlock(target) {
        //play glass break sound
        //remove the block from the scene and simulation
        //must do in a timeout because we are currently in a collide callback
        setTimeout(()=>{
            blockService.removeFromSimulation(target)
        },0)
        const v = new THREE.Vector3()
        target.userData.block.obj.localToWorld(v)
        playParticles(v)
        //add explosion effects
    }
    /*
    ignore the settle time (1 second?)
    ignore the ball hitting the floor

    find dynamic body hitting the floor
    find ball hitting dynamic body



    only create bodies when starting to play, remove completely other times. shouldn't be in the block at all?
     */
    function handleCollision(e) {
        if(ignore_collisions) return

        //ignore the ball hitting the floor
        //this is never called. why?
        if(e.body.jtype === 'ball' && e.target.jtype === 'floor') {
            console.log("floor")
            return
        }

        // console.log(e.body.jtype, 'hit', e.target.jtype, e.target.type)

        //ignore the ball hitting a static body
        if(e.body.jtype === 'ball' && e.target.type === CANNON.Body.KINEMATIC) {
            // console.log("ball hit a fixed block")
            return
        }

        if(e.body.jtype === 'ball' && e.target.type === CANNON.Body.DYNAMIC) {
            console.log("ball hit a movable block")
            ballHitMovableBlock(e.target)
            return
        }

        //if the floor hit a block
        if(e.body.jtype === 'floor' && e.target.jtype === 'block') {
            console.log("a block hit the floor")
            return;
        }

        console.log("contact",e)
        if(e.body.id === floorBody.id) return
        if(!e.contact.userData) e.contact.userData = {}
        if(e.contact.userData.soundPlayed === true) return
        playSource(audioBuffer)
        e.contact.userData.soundPlayed = true
    }
    function initBlocks(scene) {
        blockService = new BlockService(scene,handleCollision)
        const block2 = blockService.makeBlock()
        block2.positionSet(-2,1,0)
        on(block2.getObject3D(),'click',blockClicked)
        const block1 = blockService.makeBlock()
        block1.positionSet(0,1,0)
        on(block1.getObject3D(),'click',blockClicked)
        const block3 = blockService.makeBlock()
        block3.positionSet(2,1,0)
        on(block3.getObject3D(),'click',blockClicked)
        selection.add(block1)
    }

    const BASE_URL = "https://vr.josh.earth/360/doc/"
    const docid = "tumble_level3"

    function saveStructure() {
        console.log("blocks are")
        const blockData = blockService.generateJSON()
        const doc = {
            id:docid,
            type:'tumble-v1',
            data:{
                blocks:blockData
            },
        }
        console.log(JSON.stringify(doc,null,'  '))
        fetch(`${BASE_URL}${docid}`,{
            method:'POST',
            mode:'cors',
            headers: {
                'Content-Type':'application/json'
            },
            body:JSON.stringify(doc)
        })
            .then(resp => resp.json())
            .then(resp => {
                console.log("real response is",resp)
            })
            .catch(e => {
                console.log(e)
            })

    }

    function loadStructure() {
        fetch(`${BASE_URL}${docid}?cachebust=${Math.random()}`)
            .then(res => res.json())
            .then(res => {
                const blocks = blockService.loadFromJSON(res)
                blocks.forEach(b => {
                    on(b.getObject3D(), 'click', blockClicked)
                })
            })
    }

    function initPanel(scene) {

        const panel = new Panel2D(scene,camera)
        scene.add(panel)

        const subPanels = []
        function switchTo(panel) {
            subPanels.forEach(p => {
                p.set('visible',(p===panel))
            })
        }

        const posPanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',true)
            .on('changed',()=>panel.redraw())
        subPanels.push(posPanel)
        panel.push(posPanel)

        const sizPanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',false)
            .on('changed',()=>panel.redraw())
        subPanels.push(sizPanel)
        panel.push(sizPanel)

        const rotPanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',false)
            .on('changed',()=>panel.redraw())
        panel.push(rotPanel)
        subPanels.push(rotPanel)

        panel.push(new Button2D()
            .set('text','pos')
            .set('x',5).set('y',5)
            .on('changed',()=>panel.redraw())
            .on('click',()=> switchTo(posPanel))
        )
        panel.push(new Button2D()
            .set('text','siz')
            .set('x',50).set('y',5)
            .on('changed',()=>panel.redraw())
            .on('click',()=> switchTo(sizPanel))
        )
        panel.push(new Button2D()
            .set('text','rot')
            .set('x',87).set('y',5)
            .on('changed',()=>panel.redraw())
            .on('click',()=>switchTo(rotPanel))
        )

        const typePanel = new Group2D()
            .set('x',5).set('y',40)
            .set('w',245).set('h',200)
            .set('visible',false)
            .on('changed',()=>panel.redraw())
        subPanels.push(typePanel)
        panel.push(typePanel)

        panel.push(new Button2D()
            .set('text','type')
            .set('x',125).set('y',5)
            .on('changed',()=>panel.redraw())
            .on('click',()=>{
                switchTo(typePanel)
            })
        )

        typePanel.addAll([
            new Button2D()
                .set('text','movable')
                .on('changed',()=>panel.redraw())
                .on('click',()=>{
                    selection.setPropertyValue('physicstype',"dynamic")
                })
            ,
            new Button2D()
                .set('text','fixed').set('x',90)
                .on('changed',()=>panel.redraw())
                .on('click',()=>{
                    selection.setPropertyValue('physicstype',"fixed")
                })
        ])



        function redraw() {
            panel.redraw()
        }
        function makePropControls(name,y) {
            const label = new Label2D().set('x',0).set('y',y).set('text',name.toUpperCase())
            const value = new Label2D().set('x',150).set('y',y).set('text','0')
            const inc   = new Button2D().set('x',90).set('y',y).set('text','-').on('changed',redraw)
                    .on('click',()=> selection.decrementProperty(name))
            const dec   = new Button2D().set('x',120).set('y',y).set('text','+').on('changed',redraw)
                    .on('click',()=> selection.incrementProperty(name))
            on(selection,'changed',()=>{
                value.set('text',''+selection.getProperty(name))
                redraw()
            })
            return [label,inc,dec,value]
        }

        ['x','y','z'].forEach((name,i) => posPanel.addAll(makePropControls(name,40*i)));
        ["w","h","d"].forEach((name, i)=> sizPanel.addAll(makePropControls(name,40*i)));
        ["rotx","roty","rotz"].forEach((name, i)=> rotPanel.addAll(makePropControls(name,40*i)));

        panel.push(new Button2D()
            .set('text','add')
            .set('x',5)
            .set('y',300)
            .on('click',addBlock)
            .on('changed',()=>panel.redraw())
        )

        panel.push(new Button2D()
            .set('text','delete')
            .set('x',5)
            .set('y',340)
            .on('click',deleteBlock)
            .on('changed',()=>panel.redraw())
        )

        panel.push(new Button2D()
            .set('text','clone')
            .set('x',5)
            .set('y',380)
            .on('click',cloneBlock)
            .on('changed',()=>panel.redraw())
        )

        panel.push(new Button2D()
            .set('text','save')
            .set('x',5)
            .set('y',420)
            .on('click',saveStructure)
            .on('changed',()=>panel.redraw())
        )

        play_game_button = new Button2D()
            .set('text','play')
            .set('x',5)
            .set('y',460)
            .on('click',togglePlayGame)
            .on('changed',()=>panel.redraw())
        panel.push(play_game_button)

        panel.push(new Button2D()
            .set('text','front')
            .set('x',180)
            .set('y',300)
            .on('click',()=>blockService.switchToFrontView())
            .on('changed',redraw)
        )
        panel.push(new Button2D()
            .set('text','top')
            .set('x',180)
            .set('y',335)
            .on('click',()=>blockService.switchToTopView())
            .on('changed',redraw)
        )

        panel.push(new Button2D()
            .set('text','all')
            .set('x',180)
            .set('y',390)
            .on('click',()=>{
                selection.clear()
                selection.addAll(blockService.getAllBlocks())
            })
            .on('changed',redraw)
        )

        panel.redraw()
        panel.position.set(-1.5,1.5,-2)
        panel.lookAt(camera.position)
    }

    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap

        //set the background color of the scene
        scene.background = new THREE.Color( 0xcccccc );

        //a standard light
        const light = new THREE.DirectionalLight( 0xffffff, 0.5 );
        light.castShadow = true
        light.shadow.mapSize.width = 512
        light.shadow.mapSize.height = 512
        light.shadow.camera.right = 10
        light.shadow.camera.top = 10
        light.position.set( 0, 1, 1 ).normalize();
        scene.add( light );

        scene.add(new THREE.AmbientLight(0xffffff,0.5))





        // enable stats visible inside VR
        stats = new VRStats(renderer)
        camera.add(stats)
        scene.add(camera)

        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {

            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),

            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:true,

            // set to true to move the controller node forward and tilt with the mouse.
            // good for testing VR controls on desktop
            mouseSimulatesController:false,
            enableLaser: true,
            laserLength:8,
        })



        initBlocks(scene)

        initPanel(scene)

        initFloor(scene)

        initBall(scene)

        $("#overlay").style.visibility = 'hidden'
        if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')

        loadStructure()
    }

    function initFloor(scene) {
        const floor =new THREE.Mesh(
            new THREE.PlaneGeometry(30,30,32,32),
            new THREE.MeshLambertMaterial({color:'brown'})
        )
        floor.rotation.x = toRad(-90)
        floor.receiveShadow = true
        scene.add(floor)

        // Create a plane
        var groundBody = new CANNON.Body({
            mass: 0 // mass == 0 makes the body static
        });
        var groundShape = new CANNON.Plane();
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
        groundBody.addShape(groundShape);
        blockService.getWorld().addBody(groundBody);
        floorBody = groundBody
        floorBody.jtype = 'floor'


        const bg = texture_loader.load('./textures/sky2.jpg')
        const backdrop = new THREE.Mesh(
            new THREE.SphereGeometry(20),
            new THREE.MeshBasicMaterial({
                color:'white',
                map:bg,
                side: THREE.BackSide
            })
        )
        scene.add(backdrop)
    }

    const clock = new THREE.Clock()
    let press_sphere
    function startPressSphere() {
        clock.start()
        press_sphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.2),
            new THREE.MeshLambertMaterial({color:'red'})
        )
        press_sphere.scale.set(0.1,0.1,0.1)
        press_sphere.position.set(0,2,-2)
        scene.add(press_sphere)
    }
    function updatePressSphere() {
        if(press_sphere) {
            const strength = Math.min(1.0,clock.getElapsedTime()/2.0)
            press_sphere.scale.set(strength,strength,strength)
        }
    }
    function endPressSphere(e) {
        scene.remove(press_sphere)
        const strength = Math.min(1.0,clock.getElapsedTime()/2.0)
        clock.stop()
        blockService.fireBall(pointer.controller1.position, e.point.clone(),strength)
    }
    function initBall(scene) {
        click_sphere = new THREE.Mesh(
            new THREE.SphereGeometry(4),
            new THREE.MeshLambertMaterial({color:'green', side:THREE.BackSide, transparent:true, opacity:0.3})
        )
        click_sphere.visible = false
        click_sphere.userData.clickable = true
        click_sphere.position.set(0,0,0)
        scene.add(click_sphere)

        on(click_sphere,POINTER_PRESS,startPressSphere)
        on(click_sphere,POINTER_RELEASE,endPressSphere)
        // on(click_sphere,POINTER_CLICK,(e)=> {
        //     blockService.fireBall(pointer.controller1.position, e.point.clone())
        // })
    }

    //called on every frame. customize this
    function render(time) {
        T2.update(time)
        //update the pointer and stats, if configured
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        parts.forEach(part =>  part.update(time))
        blockService.update(time)
        updatePressSphere(time)
        renderer.render( scene, camera );
    }


    // you shouldn't need to modify much below here

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }



    // initPage()
    initScene()
    renderer.setAnimationLoop(render)

</script>
</body>
</html>
