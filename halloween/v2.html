<!DOCTYPE html>
<!--


autumn tree 2
https://sketchfab.com/models/3d7ba66433f64c8585c7fd3ed688c7f2

dead bush
https://sketchfab.com/models/5fcc300e817d440f826b0cb24e3c652c

dead tree
https://sketchfab.com/models/ccc4088f050a4f708f3855c71d2bd9c4


 Suoni Di Genova » ghost_yacht.wav
https://freesound.org/people/suonidigenova/sounds/55055/

 Baïkal » baik6.wav

https://freesound.org/people/ashassin/sounds/8516/


https://freesound.org/people/HF2010/sounds/110497/

-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="./node_modules/three/build/three.min.js"></script>
    <!-- needed for loading GLTF files -->
    <script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
    <!-- needed for loading Truetype Fonts -->
    <script src="./node_modules/three/examples/js/loaders/TTFLoader.js"></script>
    <script src="./node_modules/three/examples/js/libs/opentype.min.js"></script>

    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/de-puntillas-b-to-tiptoe-regular" type="text/css"/>

    <style type="text/css">
        /*
        orange: FF6515
        blue: 006C8D
        purple: 920084
        green: CAE807
        black: 000000
         */
        html, body {
            margin:0;
            padding:0;
            overflow: hidden;
        }
        h1 {
            font-family: 'dpuntillasBtotiptoeRegular';
            font-weight: normal;
            font-style: normal;
            color: #ff6f15;
            background-color: #000000;
        }
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

</head>
<body>


<div id="overlay">
    <h1>Monster Zoo</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    import {POINTER_CLICK,
        POINTER_PRESS,
        POINTER_RELEASE,
        POINTER_ENTER, POINTER_EXIT, Pointer} from '../boilerplate/pointer.js'
    import VRStats from "../boilerplate/vrstats.js"
    import {t2} from "./T2.js"
    import GPUParticleSystem from "../particles/GPUParticleSystem2.js"

    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)
    const toRad = deg => deg * Math.PI/180
    const rand = (min,max) => Math.random()*(max-min) + min

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;
    let worlds = []

    let timeLabel, monstersLabel, roundLabel

    const DEBUG = {
        FOG:true,
        MUSIC:false,
        TTF_FONT: false,
        TERRAIN:true,
        PARTICLES:false,
    }

    const CONSTS = {
        COLORS: {
            orange: '#FF6515',
            blue: '#006C8D',
            purple: '#920084',
            green: '#CAE807',
            black: '#000000',
        },
        TERRAIN_SIZE: 10,
    }
    const SCORE = {
        TIME_LEFT: 0,
        CAPTURED: 0
    }
    const MONSTERS = {
        SLIME:'SLIME',
        SKELETON:'SKELETON',
        BAT:'BAT'
    }
    const LEVELS = [
        {
            SPEED: 0.02,
            TIME: 30,
            CAPTURE:2,
            CAPTURE_TIME:1,
            MONSTER_FREQUENCY:2,
            MONSTER:MONSTERS.SLIME
        },
        {
            SPEED: 0.04,
            TIME: 30,
            CAPTURE:3,
            CAPTURE_TIME:1.5,
            MONSTER_FREQUENCY:3,
            MONSTER: MONSTERS.SKELETON,
        },
        {
            SPEED: 0.06,
            TIME: 30,
            CAPTURE:4,
            CAPTURE_TIME:2,
            MONSTER_FREQUENCY:4,
            MONSTER: MONSTERS.BAT
        }
    ]
    let currentLevel = 0
    let slime

    let intro_music, level_music, win_music, lose_music

    class SimpleText extends THREE.Object3D {
        constructor(w,h) {
            super()
            this.htmlCanvas = document.createElement('canvas')
            this.htmlCanvas.width = 128*w
            this.htmlCanvas.height = 128*h
            this.canvas_texture = new THREE.CanvasTexture(this.htmlCanvas)
            this.mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(w,h),
                new THREE.MeshLambertMaterial({map:this.canvas_texture})
            )
            this.add(this.mesh)
            // text.position.set(0,4,-4)
            // scene.add(text)
            this.font = '36px sans-serif'
            this.color = 'black';
            this.backgroundColor = 'gray'
        }
        setText(str) {
            const ctx = this.htmlCanvas.getContext('2d')
            ctx.fillStyle = this.backgroundColor
            ctx.fillRect(0,0,this.htmlCanvas.width, this.htmlCanvas.height)
            ctx.font = this.font
            ctx.fillStyle = this.color
            const metrics = ctx.measureText(str)
            ctx.fillText(str,
                this.htmlCanvas.width/2-metrics.width/2,
                (36/2+this.htmlCanvas.height/2))
            this.canvas_texture.needsUpdate = true
        }
    }

    class TTFText extends THREE.Object3D {
        constructor(url) {
            super()

            const loader = new THREE.TTFLoader()
            const fontLoader = new THREE.FontLoader()
            loader.load(url,data => {
                this.numberFont = fontLoader.parse(data)
                this.rebuildGeometry()
            })
            this.text = 'A'
        }
        rebuildGeometry() {
            if(!this.numberFont) return
            const geo = new THREE.TextGeometry(this.text,{
                font: this.numberFont,
                size: 0.5,
                height: 0.1,
            })

            this.mesh = new THREE.Group()

            const outlineMaterial = new THREE.MeshLambertMaterial({
                color:0xff0000,
                side: THREE.BackSide,
                emissive: new THREE.Color(0xff0000),
                emissiveIntensity:0.5})
            outlineMaterial.onBeforeCompile = (shader) => {
                const token = '#include <begin_vertex>'
                const customTransform = `
                vec3 transformed = position + objectNormal*0.03;
            `
                shader.vertexShader = shader.vertexShader.replace(token,customTransform)
            }

            const mesh2 = new THREE.Mesh(geo,outlineMaterial)
            // const s = 1.1
            // mesh2.scale.set(s,s,s)
            this.mesh.add(mesh2)

            const mesh  = new THREE.Mesh(geo,new THREE.MeshLambertMaterial({color:0xffffff,
                side: THREE.FrontSide,
                emissive: new THREE.Color(0xffffff),
                emissiveIntensity: 1.0
            }))
            this.mesh.add(mesh)

            this.add(this.mesh)
        }
        setText(str) {
            this.text = str
            this.remove(this.mesh)
            this.rebuildGeometry()
        }
    }

    function setupTerrain() {
        let treeCount = 0
        function makeWorld(dz) {
            const world = new THREE.Group()
            world.position.z = dz

            //scroll at constant speed over a flat plane with N seconds to capture M monsters.
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(CONSTS.TERRAIN_SIZE*4, CONSTS.TERRAIN_SIZE*2),
                new THREE.MeshLambertMaterial({color: CONSTS.COLORS.green})
            );
            // ground.material.color.setHSL(rand(0,1),1,0.5)
            ground.rotation.x = toRad(-90)
            world.add(ground)


            function makeRandomTree() {
                let r = Math.floor(Math.random()*3)
                if(r === 0) return loadMonster("./models/dead_bush/scene.gltf").then(mod => {
                    const off = new THREE.Vector3(7, -0.4, 0)
                    const obj = mod.scene.children[0]
                    obj.position.set(0, 0, 0)
                    obj.position.add(off)
                    return obj
                })
                if(r === 1) return loadMonster("./models/dead_tree/scene.gltf").then(mod => {
                    const off = new THREE.Vector3(2, 1, 15)
                    const obj = mod.scene.children[0]
                    obj.position.set(0,0,0)
                    obj.position.add(off)
                    return obj
                })
                if(r === 2) return loadMonster("./models/autumn_tree_2/scene.gltf").then(mod => {
                    const off = new THREE.Vector3(1, -7.2, 0)
                    const obj = mod.scene.children[0]
                    obj.scale.set(0.5,0.5,0.5)
                    obj.position.set(0,0,0)
                    obj.position.add(off)
                    return obj
                })
            }

            for(let i=-14; i<15; i+=4) {
                for(let j=6; j>-13; j-=4) {
                    const off = new THREE.Vector3(i+rand(-1,1),0,j+rand(-1,1))
                    // const off = new THREE.Vector3(i,0,j)
                    if(off.x > -3 && off.x < 3) {
                        continue
                    }
                    if(DEBUG.TERRAIN) makeRandomTree().then(tree => {
                        tree.position.add(off)
                        treeCount++
                        stats.setProperty('trees',treeCount)
                        world.add(tree)
                    })
                }
            }
            return world
        }
        worlds.push(makeWorld(0))
        worlds.push(makeWorld(CONSTS.TERRAIN_SIZE*-2))
        worlds.push(makeWorld(CONSTS.TERRAIN_SIZE*-4))
        worlds.forEach(w => scene.add(w))
    }
    function setupBackground() {
        scene.background = 0x000000
        scene.fog = new THREE.Fog('black',10,20)
    }
    function setupOverlay() {
        //time left in round
        if(DEBUG.TTF_FONT) {
            timeLabel = new TTFText("./fonts/d-puntillas-B-to-tiptoe.ttf")
        } else {
            timeLabel = new SimpleText(1,1)
            timeLabel.font = '64px dpuntillasBtotiptoeRegular';
            timeLabel.backgroundColor = CONSTS.COLORS.purple
            timeLabel.color = CONSTS.COLORS.green
        }
        timeLabel.position.set(-2,4,-4)
        timeLabel.setText("0")
        timeLabel.rotation.y = toRad(30)
        timeLabel.rotation.x = toRad(30)
        scene.add(timeLabel)

        t2.prop({
            target:timeLabel.rotation,
            property:'z',
            from:toRad(-10),
            to:toRad(10),
            duration:3,
            autoReverse:true,
            loop:-1
        }).start()

        //monsters left to catch
        if(DEBUG.TTF_FONT) {
            monstersLabel = new TTFText("./fonts/d-puntillas-B-to-tiptoe.ttf")
        } else {
            monstersLabel = new SimpleText(1,1)
            monstersLabel.font = '64px dpuntillasBtotiptoeRegular';
            monstersLabel.backgroundColor = CONSTS.COLORS.purple
            monstersLabel.color = CONSTS.COLORS.green
        }
        monstersLabel.position.set(2,4,-4)
        monstersLabel.setText("0")
        monstersLabel.rotation.y = toRad(-30)
        monstersLabel.rotation.x = toRad(30)
        scene.add(monstersLabel)

        t2.prop({
            target:monstersLabel.rotation,
            property:'z',
            from:toRad(10),
            to:toRad(-10),
            duration:4,
            autoReverse:true,
            loop:-1
        }).start()

        roundLabel = new SimpleText(7,1)
        roundLabel.backgroundColor = CONSTS.COLORS.black
        roundLabel.color = CONSTS.COLORS.orange

        roundLabel.position.set(0,2,-5)
        roundLabel.setText("start round")
        roundLabel.font = '48px dpuntillasBtotiptoeRegular';
        scene.add(roundLabel)
    }

    function getCurrentLevel() {
        return LEVELS[currentLevel]
    }

    let splashShowing = false
    function setupStart() {
        //show click to start
        //start round
        // when round ends you win or lose depending on how many you got.

        const splashScreen = new SimpleText(6,2)
        splashScreen.backgroundColor = CONSTS.COLORS.blue
        splashScreen.color = CONSTS.COLORS.orange
        splashScreen.setText("click to play")
        splashScreen.position.set(0,2,-4)
        scene.add(splashScreen)

        splashShowing = true
        pointer.on(POINTER_CLICK,()=>{
            if(!splashShowing) return
            splashShowing = false
            splashScreen.visible = false
            if(intro_music.isPlaying) intro_music.stop()
            restartGame()
        })

        SCORE.CAPTURED = 0
        SCORE.TIME_LEFT = 99
        SCORE.START_TIME = Date.now()
    }
    let scorch_texture
    function setupVacuum() {
        //Must focus on monster for 1 full second in a cone of influence to fully capture it.
        //         Reverse particles and is sucked into your vacuum.
        //             Get a point.
        const hose = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1,0.05,1.5),
            new THREE.MeshLambertMaterial({color:0x888888})
        )
        hose.position.y = -0.25
        const nozzle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1,0.14,0.1),
            new THREE.MeshLambertMaterial({color:0xccff00})
        )
        nozzle.position.y = 0.5
        const group = new THREE.Group()
        group.add(hose)
        group.add(nozzle)
        group.rotation.x = -90 * Math.PI/180
        group.position.z = -1.0
        pointer.controller1.add(group)

    }
    function setupCar() {
        const carBody = new THREE.Mesh(
            new THREE.CylinderGeometry(1,1,2),
            new THREE.MeshLambertMaterial({color:CONSTS.COLORS.purple})
        )
        carBody.rotation.x = toRad(90)
        carBody.position.set(0,0,0)
        scene.add(carBody)
    }

    let monsters
    function setupMonsters() {
        monsters = new THREE.Group()
        scene.add(monsters)
    }

    function setupMusic() {
        const audioListener = new THREE.AudioListener()
        camera.add(audioListener)

        const audioLoader = new THREE.AudioLoader()

        intro_music = new THREE.Audio(audioListener)
        audioLoader.load('./music/Loyalty_Freak_Music_-_01_-_Monster_Parade.mp3',(buffer) => {
            intro_music.setBuffer(buffer)
            intro_music.setVolume(0.5)
            if(DEBUG.MUSIC) intro_music.play()
        })
        level_music = new THREE.Audio(audioListener)
        audioLoader.load("./music/Loyalty_Freak_Music_-_13_-_Ghost_Surf_Rock.mp3",(buffer) => {
            level_music.setBuffer(buffer)
            level_music.setVolume(0.5)
        })
        win_music = new THREE.Audio(audioListener)
        audioLoader.load('./music/Loyalty_Freak_Music_-_12_-_Halloween_Ghost_Party.mp3',(buffer) => {
            win_music.setBuffer(buffer)
            win_music.setVolume(0.5)
        })
        lose_music = new THREE.Audio(audioListener)
        audioLoader.load('./music/Loyalty_Freak_Music_-_05_-_We_all_gonna_die_.mp3',(buffer) => {
            lose_music.setBuffer(buffer)
            lose_music.setVolume(0.5)
        })
    }

    let vacuum_sound, capture_sound
    function setupSoundEffects() {
        const audioListener = new THREE.AudioListener()
        camera.add(audioListener)

        const audioLoader = new THREE.AudioLoader()
        vacuum_sound = new THREE.Audio(audioListener)
        audioLoader.load('./sounds/55055__suonidigenova__ghost-yacht.wav', (buffer) => {
            vacuum_sound.setBuffer(buffer)
        })
        capture_sound = new THREE.Audio(audioListener)
        audioLoader.load('./sounds/110497__hf2010__voice-of-your-demise.mp3', (buffer) => {
            capture_sound.setBuffer(buffer)
        })

    }

    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        scene.background = new THREE.Color( 0xcccccc );
        const light = new THREE.DirectionalLight( 0xffffff, 0.7 );
        light.position.set( 0, 1, 1 ).normalize();
        scene.add( light );
        scene.add(new THREE.AmbientLight(0xffffff,0.2))
        stats = new VRStats(renderer)
        camera.add(stats)
        scene.add(camera)


        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {
            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),
            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:true,
            // set to true to move the controller node forward and tilt with the mouse.
            // good for testing VR controls on desktop
            mouseSimulatesController:false,

        })

        // $("#overlay").style.display = 'none'

        setupTerrain()
        if(DEBUG.FOG) setupBackground()
        setupOverlay()
        setupMonsters()
        setupVacuum()
        setupCar()
        setupStart()
        setupMusic()
        setupSoundEffects()
    }

    function moveTerrain(time) {
        const level = getCurrentLevel()
        worlds.forEach(w => {
            w.position.z += level.SPEED
            if(w.position.z > CONSTS.TERRAIN_SIZE*2) {
                w.position.z = -CONSTS.TERRAIN_SIZE*4
            }
        })
    }


    /* ============= MONSTERS =============== */

    let lastMonster = 0

    function makeScaleAnim(captureTarget, start,end) {
        const anim = t2.parallel()
        const props = ['x','y','z']
        props.forEach(p => {
            anim.and(t2.prop({
                target:captureTarget.scale,
                property:p,
                from:start,
                to:end,
                duration: 0.5
            }))
        })
        return anim
    }
    function makePositionToAnim(target, end) {
        const anim = t2.parallel()
        const props = ['x','y','z']
        props.forEach(p => {
            anim.and(t2.prop({
                target:target.position,
                property:p,
                from:target.position[p],
                to:end[p],
                duration: 0.5
            }))
        })
        return anim
    }


    let capturing = false
    let captureTarget = null
    const clock = new THREE.Clock(true)
    function showMonster(e) {
        e.target.material.color.set(0x0000FF)
        const group = e.target.parent
        const hover = new THREE.Mesh(
            new THREE.SphereGeometry(2.0),
            new THREE.MeshLambertMaterial({color:'blue',transparent:true, opacity:0.5})
        )
        hover.position.y = 0.5
        group.userData.hover = hover
        group.add(hover)
    }

    let particles
    function grabMonster(e) {
        vacuum_sound.play()
        e.target.material.color.set(0xffcccc)
        captureTarget = e.target
        capturing = true
        clock.start()
        const group = e.target.parent
        const hover = group.userData.hover
        if(hover) hover.material.color.set(0xff0000)
        if(DEBUG.PARTICLES) makeParticles(group)

    }
    function makeParticles(target) {
        const texture_loader = new THREE.TextureLoader()
        scorch_texture = texture_loader.load('../particles/kenney_particlePack/PNG/scorch_01.png')

        const options = {
            position: new THREE.Vector3(0,0,0),
            positionRandomness: 0.0,
            velocity: new THREE.Vector3(0.0, -0.5, 0.0),
            velocityRandomness: 1.0,
            acceleration: new THREE.Vector3(0.0,0.0,0.0),

            color: new THREE.Color(1.0,0.0,1.0),
            endColor: new THREE.Color(0.0,1.0,1.0),
            colorRandomness: 0.0,

            lifetime: 0.5,
            fadeIn:0.001,
            fadeOut:0.001,
            size: 60,
            sizeRandomness: 0.0,
        }

        particles = new GPUParticleSystem({
            maxParticles: 10000,
            particleSpriteTex: scorch_texture,
            blending: THREE.AdditiveBlending,
            onTick:(system,time) => {
                for (let i = 0; i < 10; i++) {
                    options.velocity.set(rand(-2,2),rand(-2,2), 0)
                    system.spawnParticle(options);
                }
            }})
        particles.position.z = -5
        particles.position.copy(target.position)
        target.userData.particles = particles
        scene.add(particles)
    }
    function releaseMonster(e) {
        if(vacuum_sound.isPlaying) vacuum_sound.stop()
        capturing = false
        e.target.material.color.set(0x00ff00)
        const group = e.target.parent
        if(group.userData.hover) {
            group.remove(group.userData.hover)
            group.userData.hover = null
        }
        if(group.userData.particles) {
            scene.remove(group.userData.particles)
            particles = null
        }
    }
    function updateCapture() {
        if(!capturing) return
        const level = getCurrentLevel()
        if(clock.getElapsedTime() > level.CAPTURE_TIME) {

            capturing = false
            SCORE.CAPTURED += 1
            monstersLabel.setText(`${SCORE.CAPTURED}`)
            const monster = captureTarget.parent
            const pos = monster.position.clone()
            t2.sequence()
                .then(t2.prop({
                    target:monster.position,
                    property:'y',
                    from:pos.y,
                    to:  pos.y+1.0,
                    duration: 0.3,
                }))
                .then(t2.prop({
                    target:monster.position,
                    property:'x',
                    from:pos.x-0.2,
                    to:  pos.x+0.2,
                    duration: 0.05,
                    autoReverse:true,
                    loop:10
                }))
                .then(t2.parallel()
                    .and(makeScaleAnim(monster,monster.scale.x,0.03))
                    .and(makePositionToAnim(monster,pointer.controller1.position.clone()))
                    .and(()=>{
                        if(capture_sound.isPlaying) capture_sound.stop()
                        capture_sound.play()
                    })
                )
                .then(()=>{
                    monster.userData.shouldRemove = true
                    const group = captureTarget.parent
                    if(group.userData.hover) {
                        group.remove(group.userData.hover)
                        group.userData.hover = null
                    }
                    if(group.userData.particles) {
                        scene.remove(group.userData.particles)
                        particles = null
                    }
                })
                .start()
        }
    }
    function loadMonster(url) {
        return new Promise((res,rej)=>{
            const loader = new THREE.GLTFLoader()
            loader.load(url,(m)=>{
                res(m)
            })
        })
    }

    function makeSlime(master) {
        const monster = master.scene
        monster.rotation.y = toRad(-90)
        //create a mesh for selection
        const grabTarget = new THREE.Mesh(
            new THREE.SphereGeometry(1.5),
            new THREE.MeshLambertMaterial({color:'green'})
        )
        grabTarget.material.visible = false
        grabTarget.position.y = 0.8
        grabTarget.userData.clickable = true
        monster.add(grabTarget)

        const s = 0.2
        monster.scale.set(s,s,s)
        monster.position.set(rand(-3, 3), 0, -20)
        monster.userData.clickable = true
        monsters.add(monster)
        on(grabTarget, POINTER_ENTER,  showMonster)
        on(grabTarget, POINTER_EXIT,  releaseMonster)
        on(grabTarget, POINTER_PRESS, grabMonster)
        on(grabTarget, POINTER_RELEASE, releaseMonster)


        t2.parallel()
            .and(t2.clip({
                target:master,
                name:'Slime_Idle',
                speed:2,
                loop:-1,
                autoReverse:true
            }))
            .and(t2.prop({
                target:monster.rotation,
                property:'y',
                from:toRad(30 - 90),
                to:toRad(-30 - 90),
                loop:-1,
                duration:1.5,
                autoReverse: true
            }))
            .start()
    }

    function makeSkeleton(master) {
        const monster = master.scene
        // monster.rotation.y = toRad(-90)
        //create a mesh for selection
        const grabTarget = new THREE.Mesh(
            new THREE.SphereGeometry(2.5),
            new THREE.MeshLambertMaterial({color:'green'})
        )
        grabTarget.material.visible = false
        grabTarget.position.y = 2.5
        grabTarget.userData.clickable = true
        monster.add(grabTarget)

        const s = 0.3
        monster.scale.set(s,s,s)
        monster.position.set(rand(-3, 3), 0, -20)
        monster.userData.clickable = true
        monsters.add(monster)
        on(grabTarget, POINTER_ENTER,  showMonster)
        on(grabTarget, POINTER_EXIT,  releaseMonster)
        on(grabTarget, POINTER_PRESS, grabMonster)
        on(grabTarget, POINTER_RELEASE, releaseMonster)


        t2.parallel()
            .and(t2.clip({
                target:master,
                // name:'Slime_Idle',
                name:'Skeleton_Attack',
                speed:1,
                loop:-1,
                autoReverse:true
            }))
            /*            .and(t2.prop({
                            target:monster.rotation,
                            property:'y',
                            from:toRad(30 - 90),
                            to:toRad(-30 - 90),
                            loop:-1,
                            duration:1.5,
                            autoReverse: true
                        }))*/
            .start()
    }

    function makeBat(master) {
        const monster = master.scene
        // monster.rotation.y = toRad(-90)
        //create a mesh for selection
        const grabTarget = new THREE.Mesh(
            new THREE.SphereGeometry(2.0),
            new THREE.MeshLambertMaterial({color:'green', wireframe:true})
        )
        grabTarget.material.visible = false
        grabTarget.position.y = 2.5
        grabTarget.userData.clickable = true
        monster.add(grabTarget)

        const s = 0.3
        monster.scale.set(s,s,s)
        monster.position.set(rand(-3, 3), 0, -20)
        monster.userData.clickable = true
        monsters.add(monster)
        on(grabTarget, POINTER_ENTER,  showMonster)
        on(grabTarget, POINTER_EXIT,  releaseMonster)
        on(grabTarget, POINTER_PRESS, grabMonster)
        on(grabTarget, POINTER_RELEASE, releaseMonster)


        t2.parallel()
            .and(t2.clip({
                target:master,
                // name:'Slime_Idle',
                name:'Bat_Flying',
                speed:1,
                loop:-1,
                // autoReverse:true
            }))
            /*            .and(t2.prop({
                            target:monster.rotation,
                            property:'y',
                            from:toRad(30 - 90),
                            to:toRad(-30 - 90),
                            loop:-1,
                            duration:1.5,
                            autoReverse: true
                        }))*/
            .start()
    }

    function updateMonsters(time) {
        if(!running) return
        const diff = (time - lastMonster)
        const level = getCurrentLevel()
        if(diff > level.MONSTER_FREQUENCY) {
            lastMonster = time
            if(level.MONSTER === MONSTERS.SLIME) loadMonster("./Slime.glb").then(makeSlime)
            if(level.MONSTER === MONSTERS.SKELETON) loadMonster("./Skeleton.glb").then(makeSkeleton)
            if(level.MONSTER === MONSTERS.BAT) loadMonster("./Bat.glb").then(makeBat)
        }
        const remove = []
        monsters.children.forEach(m => {
            m.position.z += level.SPEED
            if(m.position.z > 20) remove.push(m)
            if(m.userData.shouldRemove) remove.push(m)
        })
        remove.forEach(m => m.parent.remove(m))

        stats.setProperty('monsters',monsters.children.length)
    }




    let running = false
    function restartGame() {
        currentLevel = 0
        startLevel()
    }
    function startLevel() {
        level_music.play()
        running = true
        SCORE.START_TIME = Date.now()
        SCORE.CAPTURED = 0
        monstersLabel.setText(`${SCORE.CAPTURED}`)
        const level = getCurrentLevel()
        t2.sequence()
            .then(()=>{
                roundLabel.visible = true
                roundLabel.setText(`capture ${level.CAPTURE} in ${level.TIME} s`)
                monstersLabel.setText('0')
            })
            .wait(1)
            .then((()=> roundLabel.visible = false))
            .start()
    }

    function showNextlevelScreen() {
        running = false
        roundLabel.setText("level complete")
        roundLabel.visible = true
        const handler = () => {
            pointer.off(POINTER_CLICK,handler)
            roundLabel.visible = false
            currentLevel++
            startLevel()
        }
        pointer.on(POINTER_CLICK,handler)
    }
    function showLoseScreen() {
        running = false
        level_music.stop()
        lose_music.play()
        roundLabel.setText("game over. click to play again")
        roundLabel.visible = true
        const handler = () => {
            pointer.off(POINTER_CLICK,handler)
            roundLabel.visible = false
            lose_music.stop()
            restartGame()
        }
        pointer.on(POINTER_CLICK,handler)
    }

    function showWinScreen() {
        running = false
        level_music.stop()
        win_music.play()
        roundLabel.setText("you win. click to play again")
        roundLabel.visible = true
        const handler = () => {
            pointer.off(POINTER_CLICK,handler)
            roundLabel.visible = false
            win_music.stop()
            restartGame()
        }
        pointer.on(POINTER_CLICK,handler)
    }
    function updateTime(time) {
        if(!running) return
        const level = getCurrentLevel()
        const left = (level.TIME-Math.floor((Date.now()-SCORE.START_TIME)/1000))
        if(left !== SCORE.TIME_LEFT) {
            SCORE.TIME_LEFT = left
            timeLabel.setText(`${SCORE.TIME_LEFT}`)
        }

        if(left <= 0) {
            running = false
            const level = getCurrentLevel()
            if(SCORE.CAPTURED >= level.CAPTURE) {
                // WIN
                if (currentLevel + 1 === LEVELS.length) {
                    showWinScreen()
                } else {
                    // NEXT ROUND
                    showNextlevelScreen()
                }
            } else {
                showLoseScreen()
            }
        }
    }

    function render(time) {
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        if(particles && captureTarget) {
            const group = captureTarget.parent
            particles.position.copy(group.position)
            particles.update(time)
        }
        moveTerrain(time/1000)
        updateMonsters(time/1000)
        updateCapture(time/1000)
        updateTime(time)
        t2.update()
        renderer.render( scene, camera );
    }

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            // console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            // console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            // console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }
    initScene()
    renderer.setAnimationLoop(render)
</script>
</body>
</html>
