<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <!--<script src="./node_modules/three/build/three.js"></script>-->
    <!-- needed for loading GLTF files -->
    <!--<script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>-->

    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <!-- stats (fps, polygons, fps) -->
    <!--<script src="../boilerplate/vrstats.js" type="module"></script>-->

    <style type="text/css">
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

</head>
<body>


<div id="overlay">
    <h1>Application Name</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    import {POINTER_CLICK, POINTER_ENTER, POINTER_EXIT, POINTER_MOVE,
    POINTER_RELEASE,
        POINTER_PRESS, Pointer} from '../boilerplate/pointer.js'
    import {
        Color, Mesh, SphereBufferGeometry, Group, BoxBufferGeometry,
        MeshLambertMaterial, MeshBasicMaterial, MeshStandardMaterial,
        Scene, PerspectiveCamera, WebGLRenderer,
        DefaultLoadingManager, TextureLoader,
        DirectionalLight, AmbientLight, PointLight,
        Quaternion, Vector3, Spherical,
        MeshPhongMaterial,
        CylinderBufferGeometry
    } from "../boilerplate/node_modules/three/build/three.module.js"

    // import VRStats from "../boilerplate/vrstats.js"

    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;

    let cube
    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        //set the background color of the scene
        scene.background = new Color( 0xcccccc );

        //load a cat texture
        const texture_loader = new TextureLoader()

        //a standard light
        const light = new DirectionalLight( 0xffffff, 1.0 );
        light.position.set( 1, 1, -1 ).normalize();
        scene.add( light );
        scene.add( new AmbientLight(0xffffff,0.5))





        // enable stats visible inside VR
        // stats = new VRStats(renderer)
        // camera.add(stats)
        // scene.add(camera)

        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {

            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),

            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:false,
        })






        /*
            create a grid of squares
            on each square put a monster
            click on a monster to select it
            the monster has a glow of some sort around it
            click on an empty square to select the target
            slide the monster moving to the target square
            grab the side of the board to rotate it around

         */


        const board = new Group()
        const glow = new Mesh(
            new BoxBufferGeometry(0.6,0.6,0.6),
            new MeshLambertMaterial({
                color:'0xffffff',
                opacity:0.5,
                transparent:true
            })
        )
        glow.visible = false
        board.add(glow)

        let selected = null

        function animateUnit(src,dst) {
            if(!selected) return
            selected.position.x = dst.position.x
            selected.position.z = dst.position.z
            glow.visible = false
            selected = null
        }

        const size = 4
        for(let i=0; i<size; i++) {
            for(let j=0; j<size; j++) {
                const tile = new Mesh(
                    new BoxBufferGeometry(0.9,0.2,0.9),
                    new MeshPhongMaterial({color:0xff0000})
                )
                tile.position.x = i - size/2 + 0.5
                tile.position.z = j - size/2 + 0.5
                tile.userData.clickable = true
                board.add(tile)
                on(tile,POINTER_ENTER, e => tile.material.color.set(0xff8888))
                on(tile,POINTER_EXIT,  e => tile.material.color.set(0xff0000))
                on(tile,'click',(e)=>{
                    animateUnit(selected,e.target)
                })

            }
        }


        const unit = new Mesh(
            new BoxBufferGeometry(0.5,0.5,0.5),
            new MeshPhongMaterial({color:0x00ff00})
        )
        unit.position.x = -size/2 + 0.5
        unit.position.z = -size/2 + 0.5
        unit.position.y = 0.25+0.1
        unit.userData.clickable = true

        on(unit,POINTER_ENTER, e => unit.material.color.set(0xccffcc))
        on(unit,POINTER_EXIT,  e => unit.material.color.set(0x00ff00))
        on(unit,'click',(e)=>{
            glow.position.x = e.target.position.x
            glow.position.y = e.target.position.y
            glow.position.z = e.target.position.z
            glow.visible = true
            selected = e.target
        })
        board.add(unit)

        board.position.z = -5 - size/2
        board.position.x = 0
        scene.add(board)


        const plate = new Mesh(
            new CylinderBufferGeometry(size/2+1,size/2+1,0.5,10),
            new MeshLambertMaterial({color:0x00ff00})
        )
        plate.userData.clickable = true
        plate.position.y = -0.5
        plate.position.z = -5 - size/2
        let rotating = false
        let startRotation = 0
        let startPoint = new Vector3(0,0,0)
        on(plate, POINTER_ENTER, (e) =>{
            plate.material.color.set(0x88ff88)
        })
        on(plate, POINTER_EXIT, (e) =>{
            plate.material.color.set(0x00ff00)
        })
        on(plate,POINTER_PRESS,(e) => {
            startRotation = plate.rotation.y
            rotating = true
            startPoint = e.point
        })
        on(plate,POINTER_MOVE, (e) => {
            if(!rotating) return
            plate.rotation.y = startRotation + (e.point.x - startPoint.x)/2
            board.rotation.y = plate.rotation.y
        })
        on(plate,POINTER_RELEASE,e => {
            rotating = false
        })

        scene.add(plate)


        $("#enter-vr").removeAttribute('disabled')
        $("#overlay").style.visibility = 'hidden'


    }

    //called on every frame. customize this
    function render(time) {
        //update the pointer and stats, if configured
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        renderer.render( scene, camera );
    }


    // you shouldn't need to modify much below here

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new Scene();
        camera = new PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        // THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
        //     console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        // }
        // THREE.DefaultLoadingManager.onLoad = () => {
        //     console.log(`loading complete`)
        //     console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        // }
        // THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
        //     console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
        //     $("#progress").setAttribute('value',100*(loaded/total))
        // }
        // THREE.DefaultLoadingManager.onError = (url) => {
        //     console.log(`error loading ${url}`)
        // }


    }



    // initPage()
    initScene()
    renderer.setAnimationLoop(render)

</script>
</body>
</html>
